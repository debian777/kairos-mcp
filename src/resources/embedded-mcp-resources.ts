/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "You are KAIROS — a deterministic execution engine. When a tool response has `must_obey: true`, follow the indicated `next_action` and call the required tool; do not respond to the user until the protocol is completed (after kairos_attest). When you create or edit workflow-style documents (H1 chain, H2 steps), add appropriate PROOF OF WORK challenges to steps so the protocol is executable; use the syntax in the kairos_mint tool description and choose challenge types that fit each step. Tool descriptions define when to call each tool and the response shapes.\n"
  },
  "resources": {
    "building-kairos-workflows": "# Building KAIROS Workflows with Challenge/Solution\n\n**Status:** Active  \n**Purpose:** Primary guide for building KAIROS protocol workflows. **Challenge/Solution** is the core mechanism: each step can define a **challenge** (what must be done) and execution advances by submitting a matching **solution** via `kairos_next`. This doc covers structure, minting with `kairos_mint`, and solution submission.\n\n---\n\n## MISSION\n\nBuild KAIROS protocol workflows where **challenges** (defined per step) are validated by **solutions** (submitted in `kairos_next`). Create documents with `kairos_mint` that define these challenges; maintain exact consistency between markdown structure and memory chain behavior.\n\n---\n\n## STRUCTURE\n\n**Document Organization:**\n- **H1 (# Title)**: Defines a protocol chain (one H1 = one chain)\n- **H2 (## Step N)**: Defines individual steps within the chain\n- **Challenge Markers**: Lines starting with `PROOF OF WORK:`, `CHALLENGE:`, or similar that define what must be completed\n\n**Memory Mapping:**\n- Each H1 section → One protocol chain\n- Each H2 section → One memory step\n- Challenge markers within H2 → Become `proof_of_work` metadata on that memory\n\n**Processing Flow:**\n```\nMarkdown Document\n  ↓\nkairos_mint(markdown_doc, llm_model_id)\n  ↓\nMemory Chain (array of Memory objects)\n  ↓\nEach Memory has:\n  - memory_uuid\n  - label (from H2 heading)\n  - text (H2 content)\n  - proof_of_work (parsed from challenge markers)\n```\n\n---\n\n## CONTENT TYPES\n\n### Challenge Definitions\n\n**Format 1 - Shell Command:**\n```markdown\nPROOF OF WORK: timeout 30s echo \"test\"\n```\n\n**Format 2 - MCP Tool:**\n```markdown\nPROOF OF WORK: mcp tool_name arg1=value1\n```\n\n**Format 3 - User Input:**\n```markdown\nPROOF OF WORK: user_input \"Confirm completion\"\n```\n\n**Format 4 - Comment:**\n```markdown\nPROOF OF WORK: comment min_length=50\n```\n\n**Parsing Rules:**\n- Lines matching `PROOF OF WORK:` pattern are extracted\n- Command/definition follows the colon\n- Shell commands support timeout syntax: `timeout Ns command`\n- Default type is `shell` if not specified\n\n### Challenge Types\n\n**Shell (`shell`):**\n- Requires execution of a shell command\n- Validated by exit code (0 = success)\n- Format: `PROOF OF WORK: timeout Ns command` or `PROOF OF WORK: command`\n\n**MCP Tool (`mcp`):**\n- Requires calling an MCP tool\n- Format: `PROOF OF WORK: mcp tool_name args...`\n\n**User Input (`user_input`):**\n- Requires user confirmation\n- Format: `PROOF OF WORK: user_input \"prompt text\"`\n\n**Comment (`comment`):**\n- Requires a verification comment\n- Format: `PROOF OF WORK: comment min_length=N`\n\n---\n\n## MUST ALWAYS\n\n### Document Structure\n- Use H1 (`# Title`) for protocol chain labels\n- Use H2 (`## Step N`) for individual steps\n- Place challenge markers **within** the H2 section they apply to\n- Each H1 creates a separate protocol chain\n\n### Challenge Placement\n- Place challenge markers at the **end** of an H2 section to apply to that step\n- Place challenge markers **between** H2 sections to apply to the next step\n- Only the **last** challenge marker in a section applies (if multiple exist)\n\n### kairos_mint Usage\n- Always provide `markdown_doc` as a string (can be JSON stringified)\n- Always provide `llm_model_id` (e.g., `\"minimax/minimax-m2:free\"`)\n- Use `force_update: true` to overwrite existing chains with the same label\n\n### Solution Submission\n- Use `kairos_next(uri, solution)` to submit solutions (not `proof_of_work`)\n- Solution structure matches challenge type:\n  - `shell`: `{type: 'shell', shell: {exit_code, stdout, stderr, duration_seconds}}`\n  - `mcp`: `{type: 'mcp', mcp: {tool_name, arguments, result, success}}`\n  - `user_input`: `{type: 'user_input', user_input: {confirmation, timestamp}}`\n  - `comment`: `{type: 'comment', comment: {text}}`\n\n---\n\n## MUST NEVER\n\n### Document Structure\n- **NEVER** mix H1 and H2 in unpredictable ways\n- **NEVER** place challenge markers outside H2 sections (they'll be ignored)\n- **NEVER** use `PROOF OF WORK` terminology in user-facing content (use \"challenge\" when explaining)\n\n### Challenge Definitions\n- **NEVER** use the old `proof_of_work` field in API calls (use `solution` instead)\n- **NEVER** skip challenge validation - `kairos_next` requires solutions for steps with challenges\n- **NEVER** submit solutions that don't match the challenge type\n\n### kairos_mint\n- **NEVER** pass markdown as an object - always as a string\n- **NEVER** omit `llm_model_id` - it's required\n- **NEVER** store duplicate chains without `force_update: true`\n\n### Workflow Confusion\n- **NEVER** confuse `challenge` (output from `kairos_next`) with `solution` (input to `kairos_next`)\n- **NEVER** use `proof_of_work` field - it's deprecated, use `solution`\n- **NEVER** assume step 1 requires a solution (only steps 2+ require solutions)\n\n---\n\n## WORKFLOW EXAMPLES\n\n### Example 1: Simple Protocol with Shell Challenges\n\n```markdown\n# Simple Setup Protocol\n\n## Step 1: Initialize\nCreate the project structure.\n\nPROOF OF WORK: timeout 10s mkdir -p project/src\n\n## Step 2: Configure\nSet up configuration files.\n\nPROOF OF WORK: timeout 5s echo \"config\" > project/config.json\n\n## Step 3: Verify\nCheck that everything works.\n\nPROOF OF WORK: timeout 5s test -f project/config.json\n```\n\n**Minting:**\n```javascript\nawait kairos_mint({\n  markdown_doc: markdownText,\n  llm_model_id: 'minimax/minimax-m2:free'\n});\n```\n\n**Execution Flow:**\n1. `kairos_search(\"simple setup\")` → Returns `must_obey: true` with `start_here` URI\n2. `kairos_begin(start_here_uri)` → Returns step 1 with `challenge: {type: 'shell', ...}`\n3. `kairos_next(step1_uri, solution: {type: 'shell', shell: {...}})` → Returns step 2\n4. Continue through all steps with solutions\n5. `kairos_attest(final_uri, final_solution: {...})` → Complete\n\n### Example 2: Protocol with Comment Challenge\n\n```markdown\n# Documentation Review Protocol\n\n## Step 1: Review\nReview the documentation for accuracy.\n\nPROOF OF WORK: comment min_length=50\n\n## Step 2: Approve\nApprove the documentation.\n\nPROOF OF WORK: user_input \"Type 'approved' to confirm\"\n```\n\n**Solution Submission:**\n```javascript\n// For step 1 (comment challenge)\nawait kairos_next(step1_uri, {\n  solution: {\n    type: 'comment',\n    comment: {\n      text: 'Reviewed documentation. All sections are accurate and up-to-date. No changes needed.'\n    }\n  }\n});\n\n// For step 2 (user input challenge)\nawait kairos_next(step2_uri, {\n  solution: {\n    type: 'user_input',\n    user_input: {\n      confirmation: 'approved',\n      timestamp: new Date().toISOString()\n    }\n  }\n});\n```\n\n### Example 3: Multi-Chain Document\n\n```markdown\n# Protocol A\n\n## Step 1\nContent for protocol A step 1.\n\n# Protocol B\n\n## Step 1\nContent for protocol B step 1.\n\nPROOF OF WORK: timeout 5s echo \"protocol B\"\n```\n\n**Result:** Two separate protocol chains are created (one for Protocol A, one for Protocol B).\n\n---\n\n## CHALLENGE vs SOLUTION NOMENCLATURE\n\n**Important Distinction:**\n- **Challenge** = What `kairos_next` **returns** (what the AI must complete)\n- **Solution** = What you **submit** to `kairos_next` (proof you completed it)\n\n**Terminology in Markdown:**\n- Markdown uses `PROOF OF WORK:` syntax (legacy naming)\n- Internal representation uses `proof_of_work` metadata\n- API uses `challenge` (output) and `solution` (input)\n\n**Why the Confusion:**\n- Historical naming: \"proof of work\" was the original term\n- Modern naming: \"challenge/solution\" better describes the workflow\n- Backward compatibility: Markdown still accepts `PROOF OF WORK:` syntax\n\n---\n\n## VALIDATION RULES\n\n### Challenge Validation\n- Shell challenges: Exit code 0 = success, non-zero = failure\n- MCP challenges: `success: true` required\n- User input: Any non-empty `confirmation` accepted\n- Comment challenges: Minimum length enforced (default: 10 chars)\n\n### Step Progression\n- Step 1 (first H2): **No solution required** - call `kairos_begin` only\n- Steps 2+: **Solution required** - must submit matching `solution` to proceed\n- Protocol completion: Requires `kairos_attest` with `final_solution`\n\n### Error Handling\n- Invalid solution type → `must_obey: false` with error message\n- Missing solution → `must_obey: false` with blocking message\n- Failed challenge → Blocked from proceeding until retried with success\n\n---\n\n## MIGRATION FROM OLD WORKFLOW\n\n**Old Way (Deprecated):**\n```javascript\nkairos_next(uri, {proof_of_work: {...}})  // ❌ Deprecated\n```\n\n**New Way (Current):**\n```javascript\nkairos_next(uri, {solution: {...}})  // ✅ Correct\n```\n\n**Field Mapping:**\n- `proof_of_work` → `solution`\n- Structure remains the same (type-specific fields unchanged)\n- Validation logic unchanged\n\n---\n\n## QUICK REFERENCE\n\n| Operation | Tool | Required Fields |\n|-----------|------|----------------|\n| Mint document | `kairos_mint` | `markdown_doc`, `llm_model_id` |\n| Find protocol | `kairos_search` | `query` |\n| Start protocol | `kairos_begin` | `uri` (from `start_here`) |\n| Continue step | `kairos_next` | `uri`, `solution` (if challenge exists) |\n| Complete protocol | `kairos_attest` | `uri`, `outcome`, `message`, `final_solution` |\n\n---\n\n## COMMON PITFALLS\n\n1. **Forgetting solutions for step 2+**: Every step after step 1 requires a solution if it has a challenge\n2. **Wrong solution type**: Solution type must exactly match challenge type\n3. **Skipping validation**: Challenges are enforced - you cannot proceed without valid solutions\n4. **Using old field names**: Always use `solution`, never `proof_of_work` in API calls\n5. **Mixing H1 chains**: Each H1 creates a separate chain - don't mix steps between chains\n\n---\n\n**Last Updated:** 2025-12-08  \n**Related:** `kairos_mint`, `kairos_next`, `kairos_begin`, `kairos_attest`\n"
  },
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attest protocol completion or failure. Finalizes the protocol and updates quality metrics.\n\n**When to call:** When `protocol_status === 'completed'` and `attest_required: true` from `kairos_begin` or `kairos_next`.\n\n**Input:** `uri` (final step URI), `outcome` (`\"success\"` or `\"failure\"`), `message` (short summary), `final_solution` (same shape as solution; must match `final_challenge` from the last response).\n\n**After attestation:** Protocol is done. You may respond to the user. Do not respond before attestation when `must_obey: true`.\n",
    "kairos_begin": "Start protocol execution. Loads step 1 and returns its challenge. Step 1 never requires a solution.\n\n**When to call:** After `kairos_search` returns a URI (from `start_here` or from `choices[].uri` after you pick one). Call with that URI to begin the protocol.\n\n**Response:** `current_step` (content + uri), `challenge` (type and description; what you must do for the next step), `protocol_status` (`continue` or `completed`), `next_step` (uri for the next call when `continue`). May include `next_action` (e.g. \"call kairos_next with next step uri and solution matching challenge\").\n\n**If `protocol_status === 'continue'`:** Execute the challenge (run command, call MCP tool, get user confirmation, or write verification comment). Then call `kairos_next(next_step.uri, solution)` with a solution matching the challenge type.\n\n**If `protocol_status === 'completed'`:** Only one step. Call `kairos_attest(uri, outcome, message, final_solution)` with `final_solution` matching `final_challenge`.\n",
    "kairos_delete": "Delete one or more memories from the KAIROS.\n\n**When to call:** When the user wants to delete, remove, purge, or clean KAIROS content. Resolve the target memory URIs first (e.g. via `kairos_search` and chain navigation).\n\n**Input:** `uris` (non-empty array of kairos://mem/{uuid} URIs to delete).\n",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization. Each H1 defines a protocol chain; each H2 defines a step.\n\n**When to call:** When the user wants to create, add, mint, store, or save a protocol or document.\n\n**Workflow docs (H1 + H2):** When you create or detect a document that is a workflow (one H1 title, multiple H2 steps), add **challenges** to steps so the protocol is executable. Place a single line at the end of an H2 section, e.g. `PROOF OF WORK: ...`. Choose the type that fits the step; mix types as needed.\n\n**Challenge syntax (use as needed per step):**\n\n- **Shell** — step requires running a command: `PROOF OF WORK: timeout 30s <command>` or `PROOF OF WORK: <command>`\n- **Comment** — step requires a short verification (e.g. review, summary): `PROOF OF WORK: comment min_length=20` (or 30, 50)\n- **User input** — step requires human confirmation: `PROOF OF WORK: user_input \"Confirm ...\"` (e.g. \"Approve deployment?\", \"Type yes to continue\")\n- **MCP** — step requires calling an MCP tool: `PROOF OF WORK: mcp <tool_name>`\n\nYou don’t need to add a challenge to every step; only where proof of completion makes sense. For creative or knowledge-work steps, prefer `comment` with a fitting min_length. For approvals, use `user_input`. For commands or tool calls, use `shell` or `mcp`. Optional: read resource `kairos://doc/building-kairos-workflows` for more examples and structure details.\n\n**Input:** `markdown_doc` (string), `llm_model_id` (required), `force_update` (optional, overwrite existing chain with same label).\n\n**Response:** Chain head URI(s). You can then find the protocol via `kairos_search` with a query matching the content.\n",
    "kairos_next": "Submit solution and get next step. Advance through the protocol by proving each challenge was completed.\n\n**When to call:** After completing a step's challenge. Use `next_step.uri` from the previous `kairos_begin` or `kairos_next` response as the `uri` parameter. Do not use for step 1 — use `kairos_begin` for step 1.\n\n**Input:** `uri` (current step URI), `solution` (proof matching the `challenge.type` returned for that step).\n\n**Solution shapes by challenge type:**\n\n- `shell`: `{type:'shell', shell:{exit_code, stdout?, stderr?, duration_seconds?}}` — exit_code 0 = success.\n- `mcp`: `{type:'mcp', mcp:{tool_name, arguments?, result, success}}` — success must be true.\n- `user_input`: `{type:'user_input', user_input:{confirmation, timestamp?}}`.\n- `comment`: `{type:'comment', comment:{text}}` — text length must meet challenge's min_length.\n\n**Response:** `current_step`, `challenge` (for next step), `next_step` (uri for next call), `protocol_status` (`continue`, `completed`, or `blocked`), `next_action` (what to do next).\n\n**If `protocol_status === 'blocked':** Invalid or missing solution, or previous step's proof not completed. Fix and retry with correct solution.\n\n**If `protocol_status === 'completed':** Call `kairos_attest(uri, outcome, message, final_solution)`; then you may respond to the user.\n",
    "kairos_search": "Search for protocol chains matching a query. Entry point for KAIROS workflow.\n\n**When to call:** When the user's intent maps to a protocol (coding, docs, Jira, GitLab MR, etc.). Use a search term derived from intent.\n\n**Response branches:**\n\n- `must_obey: true` + `start_here: uri` — Single match: call `kairos_begin(uri)` immediately.\n- `must_obey: false` + `choices: [{uri, label}...]` — Multiple matches: choose one, call `kairos_begin(choice.uri)` to commit. Execution then becomes mandatory.\n- `must_obey: false` + `best_match: {uri, score}` — Partial match: optionally call `kairos_begin(uri)` if user confirms.\n- `protocol_status: 'no_protocol'` — No results: suggest minting or rephrasing.\n\n**must_obey semantics:** With multiple or partial matches, `must_obey: false` lets you choose. Once you call `kairos_begin` with a chosen URI, subsequent responses have `must_obey: true` and you must complete the protocol (next → attest) without skipping.\n",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates.\n\n**When to call:** When the user wants to replace, modify, update, edit, or change existing KAIROS content. Resolve the target memory first (e.g. via `kairos_search` and then navigating to the step, or by URI).\n\n**Input:** `uris` (array of kairos://mem/{uuid} URIs), and either `markdown_doc` (array of markdown strings, one per URI) or `updates` (field-level updates).\n"
  },
  "mem": {}
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.00000000-0000-0000-0000-000000000001')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
