/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "You are KAIROS — a deterministic execution engine for protocol chains.\n\nYou turn user intent into a KAIROS protocol run, then execute it exactly.\nProtocols are stored as memory chains. Each step can define a proof-of-work\nchallenge. You advance a protocol by submitting a matching solution.\n\n## Use KAIROS strengths\n\nUse KAIROS to be reliable and fast.\n\n- Deterministic next actions: follow `next_action` instead of improvising.\n- Verifiable work: treat every challenge as something you must prove.\n- Self-healing: when a step is broken, fix the protocol for next time.\n- Reuse: prefer running an existing protocol over inventing a new workflow.\n\n## Non-negotiable rules\n\nThese rules override your default behavior.\n\n- If a tool response includes `must_obey: true`, follow `next_action` exactly.\n  Do not respond to the user until the protocol run is complete (when\n  `next_action` says \"Run complete.\").\n- If a tool response includes `must_obey: false`, use judgment. Choose the best\n  option described in `next_action`. Prefer repairing the protocol with\n  `kairos_update` when safe. Otherwise, ask the user.\n- Do not guess. If you need facts from the codebase, environment, or external\n  systems, use tools to get them.\n\n## Execution loop\n\nFollow this loop for any protocol run.\n\n1. If the user intent matches a stored protocol, call `kairos_search`.\n2. Choose a protocol from `choices`, then call `kairos_begin` with its `uri`.\n3. While `next_action` says to call `kairos_next`:\n   - Read the `challenge` for the current step.\n   - Complete the work in the real world.\n   - Call `kairos_next` with the URI from `next_action` and a `solution` that\n     matches `challenge.type`.\n   - Echo `challenge.nonce` as `solution.nonce` when present.\n   - Echo the correct `proof_hash` as `solution.proof_hash`.\n     - For step 1, use `challenge.proof_hash`.\n     - For later steps, use the `proof_hash` returned by the previous\n       `kairos_next`.\n   - Never compute hashes yourself. The server generates all hashes.\n4. When `next_action` says \"Run complete.\", the protocol run is done; you may respond to the user.\n\n## Create or edit protocols\n\nWhen you mint or edit a workflow document (H1 chain, H2 steps), add a single\n`PROOF OF WORK: ...` line to steps that must be executed or verified. Choose\nthe challenge type that matches the work: `shell`, `mcp`, `user_input`, or\n`comment`.\n"
  },
  "resources": {
    "building-kairos-workflows": "# Building KAIROS Workflows with Challenge/Solution\n\n**Status:** Active  \n**Purpose:** Primary guide for building KAIROS protocol workflows. **Challenge/Solution** is the core mechanism: each step can define a **challenge** (what must be done) and execution advances by submitting a matching **solution** via `kairos_next`. This doc covers structure, minting with `kairos_mint`, and solution submission.\n\n---\n\n## MISSION\n\nBuild KAIROS protocol workflows where **challenges** (defined per step) are validated by **solutions** (submitted in `kairos_next`). Create documents with `kairos_mint` that define these challenges; maintain exact consistency between markdown structure and memory chain behavior.\n\n---\n\n## STRUCTURE\n\n**Document Organization:**\n- **H1 (# Title)**: Defines a protocol chain (one H1 = one chain)\n- **H2 (## Step N)**: Defines individual steps within the chain\n- **Challenge Markers**: Lines starting with `PROOF OF WORK:`, `CHALLENGE:`, or similar that define what must be completed\n\n**Memory Mapping:**\n- Each H1 section → One protocol chain\n- Each H2 section → One memory step\n- Challenge markers within H2 → Become `proof_of_work` metadata on that memory\n\n**Processing Flow:**\n```\nMarkdown Document\n  ↓\nkairos_mint(markdown_doc, llm_model_id)\n  ↓\nMemory Chain (array of Memory objects)\n  ↓\nEach Memory has:\n  - memory_uuid\n  - label (from H2 heading)\n  - text (H2 content)\n  - proof_of_work (parsed from challenge markers)\n```\n\n---\n\n## CONTENT TYPES\n\n### Challenge Definitions\n\n**Format 1 - Shell Command:**\n```markdown\nPROOF OF WORK: timeout 30s echo \"test\"\n```\n\n**Format 2 - MCP Tool:**\n```markdown\nPROOF OF WORK: mcp tool_name arg1=value1\n```\n\n**Format 3 - User Input:**\n```markdown\nPROOF OF WORK: user_input \"Confirm completion\"\n```\n\n**Format 4 - Comment:**\n```markdown\nPROOF OF WORK: comment min_length=50\n```\n\n**Parsing Rules:**\n- Lines matching `PROOF OF WORK:` pattern are extracted\n- Command/definition follows the colon\n- Shell commands support timeout syntax: `timeout Ns command`\n- Default type is `shell` if not specified\n\n### Challenge Types\n\n**Shell (`shell`):**\n- Requires execution of a shell command\n- Validated by exit code (0 = success)\n- Format: `PROOF OF WORK: timeout Ns command` or `PROOF OF WORK: command`\n\n**MCP Tool (`mcp`):**\n- Requires calling an MCP tool\n- Format: `PROOF OF WORK: mcp tool_name args...`\n\n**User Input (`user_input`):**\n- Requires user confirmation\n- Format: `PROOF OF WORK: user_input \"prompt text\"`\n\n**Comment (`comment`):**\n- Requires a verification comment\n- Format: `PROOF OF WORK: comment min_length=N`\n\n---\n\n## MUST ALWAYS\n\n### Document Structure\n- Use H1 (`# Title`) for protocol chain labels\n- Use H2 (`## Step N`) for individual steps\n- Place challenge markers **within** the H2 section they apply to\n- Each H1 creates a separate protocol chain\n\n### Challenge Placement\n- Place challenge markers at the **end** of an H2 section to apply to that step\n- Place challenge markers **between** H2 sections to apply to the next step\n- Only the **last** challenge marker in a section applies (if multiple exist)\n\n### kairos_mint Usage\n- Always provide `markdown_doc` as a string (can be JSON stringified)\n- Always provide `llm_model_id` (e.g., `\"minimax/minimax-m2:free\"`)\n- Use `force_update: true` to overwrite existing chains with the same label\n\n### Solution Submission\n- Use `kairos_next(uri, solution)` to submit solutions (not `proof_of_work`)\n- Solution structure matches challenge type:\n  - `shell`: `{type: 'shell', shell: {exit_code, stdout, stderr, duration_seconds}}`\n  - `mcp`: `{type: 'mcp', mcp: {tool_name, arguments, result, success}}`\n  - `user_input`: `{type: 'user_input', user_input: {confirmation, timestamp}}`\n  - `comment`: `{type: 'comment', comment: {text}}`\n\n---\n\n## MUST NEVER\n\n### Document Structure\n- **NEVER** mix H1 and H2 in unpredictable ways\n- **NEVER** place challenge markers outside H2 sections (they'll be ignored)\n- **NEVER** use `PROOF OF WORK` terminology in user-facing content (use \"challenge\" when explaining)\n\n### Challenge Definitions\n- **NEVER** use the old `proof_of_work` field in API calls (use `solution` instead)\n- **NEVER** skip challenge validation - `kairos_next` requires solutions for steps with challenges\n- **NEVER** submit solutions that don't match the challenge type\n\n### kairos_mint\n- **NEVER** pass markdown as an object - always as a string\n- **NEVER** omit `llm_model_id` - it's required\n- **NEVER** store duplicate chains without `force_update: true`\n\n### Workflow Confusion\n- **NEVER** confuse `challenge` (output from `kairos_next`) with `solution` (input to `kairos_next`)\n- **NEVER** use `proof_of_work` field - it's deprecated, use `solution`\n- **NEVER** assume step 1 requires a solution (only steps 2+ require solutions)\n\n---\n\n## WORKFLOW EXAMPLES\n\n### Example 1: Simple Protocol with Shell Challenges\n\n```markdown\n# Simple Setup Protocol\n\n## Step 1: Initialize\nCreate the project structure.\n\nPROOF OF WORK: timeout 10s mkdir -p project/src\n\n## Step 2: Configure\nSet up configuration files.\n\nPROOF OF WORK: timeout 5s echo \"config\" > project/config.json\n\n## Step 3: Verify\nCheck that everything works.\n\nPROOF OF WORK: timeout 5s test -f project/config.json\n```\n\n**Minting:**\n```javascript\nawait kairos_mint({\n  markdown_doc: markdownText,\n  llm_model_id: 'minimax/minimax-m2:free'\n});\n```\n\n**Execution Flow:**\n1. `kairos_search(\"simple setup\")` -> Returns `must_obey: true` with `next_action` containing URI\n2. `kairos_begin(uri)` -> Returns step 1 with `challenge` and `next_action` with next URI\n3. `kairos_next(step2_uri, solution: {type: 'shell', proof_hash: '...', shell: {...}})` -> Returns step 2\n4. Continue through all steps with solutions (echo `proof_hash` from each response)\n5. `kairos_attest(final_uri, outcome, message)` -> Complete (no final_solution needed)\n\n### Example 2: Protocol with Comment Challenge\n\n```markdown\n# Documentation Review Protocol\n\n## Step 1: Review\nReview the documentation for accuracy.\n\nPROOF OF WORK: comment min_length=50\n\n## Step 2: Approve\nApprove the documentation.\n\nPROOF OF WORK: user_input \"Type 'approved' to confirm\"\n```\n\n**Solution Submission:**\n```javascript\n// For step 1 (comment challenge)\nawait kairos_next(step1_uri, {\n  solution: {\n    type: 'comment',\n    comment: {\n      text: 'Reviewed documentation. All sections are accurate and up-to-date. No changes needed.'\n    }\n  }\n});\n\n// For step 2 (user input challenge)\nawait kairos_next(step2_uri, {\n  solution: {\n    type: 'user_input',\n    user_input: {\n      confirmation: 'approved',\n      timestamp: new Date().toISOString()\n    }\n  }\n});\n```\n\n### Example 3: Multi-Chain Document\n\n```markdown\n# Protocol A\n\n## Step 1\nContent for protocol A step 1.\n\n# Protocol B\n\n## Step 1\nContent for protocol B step 1.\n\nPROOF OF WORK: timeout 5s echo \"protocol B\"\n```\n\n**Result:** Two separate protocol chains are created (one for Protocol A, one for Protocol B).\n\n---\n\n## CHALLENGE vs SOLUTION NOMENCLATURE\n\n**Important Distinction:**\n- **Challenge** = What `kairos_next` **returns** (what the AI must complete)\n- **Solution** = What you **submit** to `kairos_next` (proof you completed it)\n\n**Terminology in Markdown:**\n- Markdown uses `PROOF OF WORK:` syntax (legacy naming)\n- Internal representation uses `proof_of_work` metadata\n- API uses `challenge` (output) and `solution` (input)\n\n**Why the Confusion:**\n- Historical naming: \"proof of work\" was the original term\n- Modern naming: \"challenge/solution\" better describes the workflow\n- Backward compatibility: Markdown still accepts `PROOF OF WORK:` syntax\n\n---\n\n## VALIDATION RULES\n\n### Challenge Validation\n- Shell challenges: Exit code 0 = success, non-zero = failure\n- MCP challenges: `success: true` required\n- User input: Any non-empty `confirmation` accepted\n- Comment challenges: Minimum length enforced (default: 10 chars)\n\n### Step Progression\n- Step 1 (first H2): **No solution required** - call `kairos_begin` only\n- Steps 2+: **Solution required** - must submit matching `solution` to proceed\n- Include `nonce` and `proof_hash` in solution (echo from challenge/response)\n- Protocol completion: Call `kairos_attest` with `uri`, `outcome`, and `message` (no `final_solution`)\n\n### Error Handling (Two-Phase Retry)\n- Retries 1-3: `must_obey: true` with `error_code` and `next_action` for recovery\n- After 3 retries: `must_obey: false` - AI gets autonomy (fix step, abort, or ask user)\n- Error responses include `error_code` (e.g., `NONCE_MISMATCH`, `TYPE_MISMATCH`) and `retry_count`\n\n---\n\n## MIGRATION FROM OLD WORKFLOW\n\n**Old Way (Deprecated):**\n```javascript\nkairos_next(uri, {proof_of_work: {...}})  // ❌ Deprecated\n```\n\n**New Way (Current):**\n```javascript\nkairos_next(uri, {solution: {...}})  // ✅ Correct\n```\n\n**Field Mapping:**\n- `proof_of_work` → `solution`\n- Structure remains the same (type-specific fields unchanged)\n- Validation logic unchanged\n\n---\n\n## QUICK REFERENCE\n\n| Operation | Tool | Required Fields |\n|-----------|------|----------------|\n| Mint document | `kairos_mint` | `markdown_doc`, `llm_model_id` |\n| Find protocol | `kairos_search` | `query` |\n| Start protocol | `kairos_begin` | `uri` (from `next_action`) |\n| Continue step | `kairos_next` | `uri` (from `next_action`), `solution` with `nonce` + `proof_hash` |\n| Complete protocol | `kairos_attest` | `uri`, `outcome`, `message` |\n\n---\n\n## COMMON PITFALLS\n\n1. **Forgetting solutions for step 2+**: Every step after step 1 requires a solution if it has a challenge\n2. **Wrong solution type**: Solution type must exactly match challenge type\n3. **Skipping validation**: Challenges are enforced - you cannot proceed without valid solutions\n4. **Using old field names**: Always use `solution`, never `proof_of_work` in API calls\n5. **Mixing H1 chains**: Each H1 creates a separate chain - don't mix steps between chains\n\n---\n\n**Last Updated:** 2025-12-08  \n**Related:** `kairos_mint`, `kairos_next`, `kairos_begin`, `kairos_attest`\n"
  },
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attest protocol completion or failure. Updates quality metrics for the last step.\n\n**Deprecated:** No longer part of the default protocol. Quality is updated in `kairos_next`; the run is complete when `next_action` says \"Run complete.\" You do not need to call `kairos_attest`. This tool remains available for optional override (e.g. to set outcome or message after the fact) or backward compatibility.\n\n**Input:** `uri` (last step URI), `outcome` (`\"success\"` or `\"failure\"`), `message` (short summary of how the protocol went). No `final_solution` required.\n\n**After attestation:** Protocol is done. You may respond to the user. Do not respond before attestation when `must_obey: true`.\n",
    "kairos_begin": "Start protocol execution. Loads step 1 and returns its challenge. Step 1 never requires a solution.\n\n**When to call:** After `kairos_search` returns a URI in `next_action`. Call with that URI to begin the protocol. If a non-step-1 URI is provided, KAIROS auto-redirects to step 1.\n\n**Response:** `current_step` (content + uri), `challenge` (type, description, nonce, proof_hash), and `next_action` with the exact URI for the next call.\n\n**AI decision tree:** `must_obey: true` -> follow `next_action`.\n\n- If `next_action` mentions `kairos_next`: Execute the challenge, then call `kairos_next` with the URI from `next_action` and a solution matching the challenge.\n- If `next_action` says \"Run complete.\": Single-step protocol; run is done. You may respond to the user.\n\n**Proof hash:** Echo `challenge.proof_hash` back as `solution.proof_hash` in the next `kairos_next` call. The server generates all hashes; the AI never computes them.\n",
    "kairos_delete": "Delete one or more memories from the KAIROS.\n\n**When to call:** When the user wants to delete, remove, purge, or clean KAIROS content. Resolve the target memory URIs first (e.g. via `kairos_search` and chain navigation).\n\n**Input:** `uris` (non-empty array of kairos://mem/{uuid} URIs to delete).\n",
    "kairos_dump": "Read-only inspection of a memory or full protocol. Returns **markdown_doc** for use with `kairos_update` or `kairos_mint`. No run state, no nonce.\n\n**When to call:** When you have a memory URI and need to read its content before updating or re-minting. For example: after `kairos_mint` returns SIMILAR_MEMORY_FOUND (dump the existing protocol to compare), or before calling `kairos_update` to edit a step.\n\n**Input:** `uri` (kairos://mem/{uuid}), optional `protocol` (default false). When `protocol` is true, returns the full chain as one markdown document; otherwise returns the single step’s content.\n\n**Output:** `markdown_doc` (string). In default mode also optional `uri`, `label`, `position`, `challenge`. In protocol mode also optional `uri` (chain head), `label`, `step_count`.\n\n**Use with update:** Get `markdown_doc` for one step → edit → `kairos_update({ uris: [uri], markdown_doc: [markdown_doc] })`.\n\n**Use with mint:** Get `markdown_doc` with `protocol: true` → compare or edit → `kairos_mint({ markdown_doc, llm_model_id, force_update: true })`.\n\nDo not use dump to bypass execution; use it only for inspection and round-trip edit flows.\n",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization. Each H1 defines a protocol chain; each H2 defines a step.\n\n**When to call:** When the user wants to create, add, mint, store, or save a protocol or document.\n\n**Challenge:** For each step that can be verified, add a fenced ` ```json ` block at the end with an object that has a `challenge` key. The value is the same shape as the `challenge` returned by kairos_begin/kairos_next; round-trips with kairos_dump. Legacy `PROOF OF WORK: ...` lines are still accepted for backward compatibility.\n\n**Challenge examples (one per type; use a ` ```json ` code block at the end of each step):**\n\n**shell** — run a command:\n\n```json\n{\n  \"challenge\": {\n    \"type\": \"shell\",\n    \"shell\": {\n      \"cmd\": \"npm test\",\n      \"timeout_seconds\": 60\n    },\n    \"required\": true\n  }\n}\n```\n\n**comment** — verification text (min length):\n\n```json\n{\n  \"challenge\": {\n    \"type\": \"comment\",\n    \"comment\": { \"min_length\": 50 },\n    \"required\": true\n  }\n}\n```\n\n**user_input** — human confirmation:\n\n```json\n{\n  \"challenge\": {\n    \"type\": \"user_input\",\n    \"user_input\": { \"prompt\": \"Approve deployment?\" },\n    \"required\": true\n  }\n}\n```\n\n**mcp** — call MCP tool:\n\n```json\n{\n  \"challenge\": {\n    \"type\": \"mcp\",\n    \"mcp\": { \"tool_name\": \"kairos_mint\" },\n    \"required\": true\n  }\n}\n```\n\nUse a challenge on every step that can be verified: commands → shell; reviews/summaries → comment; approvals → user_input; tool calls → mcp. Mix types in one protocol. See workflow-kairos-mint and the creation protocol (kairos://mem/00000000-0000-0000-0000-000000002001) for full examples.\n\n**Input:** `markdown_doc` (string), `llm_model_id` (required), `force_update` (optional, overwrite existing chain with same label).\n\n**Response:** Chain head URI(s). You can then find the protocol via `kairos_search` with a query matching the content.\n",
    "kairos_next": "Submit solution and get next step. Advance through the protocol by proving each challenge was completed.\n\n**When to call:** After completing a step's challenge. Use the URI from `next_action` of the previous response. Do not use for step 1 — use `kairos_begin` for step 1.\n\n**Input:** `uri` (current step URI from `next_action`), `solution` (proof matching the `challenge.type`).\n\n**Solution shapes by challenge type:**\n\n- `shell`: `{type:'shell', shell:{exit_code, stdout?, stderr?, duration_seconds?}}` — exit_code 0 = success.\n- `mcp`: `{type:'mcp', mcp:{tool_name, arguments?, result, success}}` — success must be true.\n- `user_input`: `{type:'user_input', user_input:{confirmation, timestamp?}}`.\n- `comment`: `{type:'comment', comment:{text}}` — text length must meet challenge's min_length.\n\nInclude in solution when the challenge has them: `nonce` (echo from challenge), `proof_hash` (echo `challenge.proof_hash` for step 1; for step 2+ use `proof_hash` from the previous `kairos_next` response). The server generates all hashes; the AI never computes them.\n\n**Response:** `current_step`, `challenge` (for next step), `next_action` (next tool call with embedded URI), and `proof_hash` (hash of proof just stored — use as `solution.proof_hash` for the next step).\n\n**AI decision tree:**\n- `must_obey: true` -> follow `next_action` (success or recoverable error, retries 1-3).\n- `must_obey: false` -> use judgment (max retries exceeded). Options in `next_action`: fix the step via `kairos_update`, abort via `kairos_attest` with failure, or ask the user.\n\n**Error responses** include `error_code` (e.g., `NONCE_MISMATCH`, `TYPE_MISMATCH`, `MAX_RETRIES_EXCEEDED`) and `retry_count`. A fresh `challenge` with new nonce is provided for self-correction.\n\n**When `next_action` says \"Run complete.\":** Protocol run is done; you may respond to the user.\n",
    "kairos_search": "Search for protocol chains matching a query. Entry point for KAIROS workflow.\n\n**When to call:** When the user's intent maps to a protocol (coding, docs, Jira, GitLab MR, etc.). Use a search term derived from intent.\n\n**Response:** Always `must_obey: true`. Contains `choices` array (each with `uri`, `label`, `chain_label`, `score`, `role`, `tags`, `next_action`), `message`, and a global `next_action` directive.\n\n**AI decision tree:** `must_obey: true` -> pick one choice and follow **that choice's `next_action`**. The global `next_action` says: \"Pick one choice and follow that choice's next_action.\" (or \"Follow the choice's next_action.\" when there is only one choice.)\n\n**Choices roles:**\n- `role: \"match\"` — search results with a `score` (0.0-1.0). Higher = better match. That choice's `next_action` tells you to call `kairos_begin` with its URI.\n- `role: \"refine\"` — option to search again with more words or details. That choice's `next_action` tells you to call `kairos_search` with more words/details.\n- `role: \"create\"` — system action to create a new protocol (`score: null`). That choice's `next_action` tells you to call `kairos_begin` with the creation protocol URI.\n\n**Ordering:** Match choices first (top N from search), then refine (if present), then create (if present). Refine and create are not part of the search limit.\n\n**After search:** Pick the choice that best fits user intent (use `label`, `chain_label`, `tags`, `score`). Then follow that choice's `next_action` exactly (either `kairos_begin` with a URI or `kairos_search` with more words/details).\n",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates.\n\n**When to call:** When the user wants to replace, modify, update, edit, or change existing KAIROS content. Resolve the target memory first (e.g. via `kairos_search` and then navigating to the step, or by URI).\n\n**Input:** `uris` (array of kairos://mem/{uuid} URIs), and either `markdown_doc` (array of markdown strings, one per URI) or `updates` (field-level updates).\n"
  },
  "mem": {}
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.<uuid>')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
