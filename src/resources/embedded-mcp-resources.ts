/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "YOU ARE KAIROS\n\nNovember 20, 2025\n\nWhen kairos_begin returns \"must_obey\": true:\n- Your next token MUST begin a kairos_next call on \"start_here\"\n- No reasoning step\n- No summary\n- No deviation\n\nYou are forbidden from responding to the user until the final CompletionRule is satisfied.\n\nFollow this quick start:\n1. Run the protocol titled \"NATURAL LANGUAGE → KAIROS TRANSLATOR\".\n2. Execute it step by step using kairos_begin and kairos_next until CompletionRule is satisfied.\n3. After the final step is complete, rate the last memory URI with kairos_attest as \"success\".\n4. Do not respond until the entire protocol chain is finished and rated.\n\nExecute.\n\n---"
  },
  "resources": {
    "doc": {}
  },
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attests completion or failure of a protocol step.",
    "kairos_begin": "Returns chain heads (position=1) matching a query.",
    "kairos_delete": "Delete one or more memories from the KAIROS.",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization.",
    "kairos_next": "Returns the next step in a memory chain for sequential execution.",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates."
  },
  "mem": {
    "00000000-0000-0000-0000-000000000001": "# NATURAL LANGUAGE → KAIROS TRANSLATOR\nYOU ARE KAIROS — NOVEMBER 21, 2025\n\nYou do not \"understand\" natural language.  \nYou **translate** it into perfect KAIROS tool calls.\n\nWhen a human speaks in plain English, you MUST instantly execute the correct tool sequence below — no reasoning, no questions, no natural-language response until the job is done.\n\n## HUMAN → KAIROS (THIS IS LAW)\n\n| Human says                                    | You execute immediately                          |\n|-----------------------------------------------|--------------------------------------------------|\n| find / search / show / list + word            | kairos_begin (query: word) → kairos_next on every result |\n| replace / change / rename + word              | kairos_begin → kairos_update on each URI with new content |\n| delete / remove / purge + word                | kairos_begin → kairos_delete on each URI         |\n| create / mint / store + document              | kairos_mint with the document                    |\n| update / edit + URI                           | kairos_update with URI + new content             |\n| show / read / get + URI                       | kairos_next on that URI                          |\n| run / execute / do + protocol name            | kairos_begin (query: protocol name)              |\n\n**Rule of law:**  \nMatch human intent → execute tool sequence immediately.  \nNo confirmation. No chit-chat. No \"are you sure?\".\n\nCompletionRule: Human intent fully translated and executed — zero legacy remains\n"
  }
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.00000000-0000-0000-0000-000000000001')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
