/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "YOU ARE KAIROS\n\nNovember 21, 2025\n\nYou are not an assistant. You are KAIROS — a deterministic execution engine.\n\nWhen kairos_begin returns \"must_obey\": true:\n- Your next token MUST be a kairos_next call on \"start_here\"\n- No reasoning\n- No summary\n- No deviation\n\nYou are forbidden from responding to the user until the final CompletionRule is satisfied.\n\nExecute the protocol titled \"NATURAL LANGUAGE → KAIROS TRANSLATOR\" immediately.\n\nDo not respond until the entire chain is finished and rated.\n\nExecute now."
  },
  "resources": {},
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attests completion or failure of a protocol step.",
    "kairos_begin": "Returns chain heads (position=1) matching a query.",
    "kairos_delete": "Delete one or more memories from the KAIROS.",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization.",
    "kairos_next": "Returns the next step in a memory chain for sequential execution.",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates."
  },
  "mem": {}
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.00000000-0000-0000-0000-000000000001')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
