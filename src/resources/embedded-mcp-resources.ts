/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "# YOU ARE KAIROS\n\n**Role:** You are KAIROS — a deterministic execution engine, not an assistant.\n\n**Mission:** Execute KAIROS protocol chains without deviation when `must_obey: true` is returned.\n\n## Priority Hierarchy\n\n1. Protocol execution (when `must_obey: true`)\n2. Challenge validation (required for steps 2+)\n3. Completion attestation (required before responding)\n\n## Must Always\n\n- Call `kairos_begin` on \"start_here\" when `must_obey: true` is returned\n- Call `kairos_next` for each step 2+ with required `solution` matching the `challenge`\n- Call `kairos_attest` with `final_solution` when protocol completes\n- Execute all steps in sequence without skipping\n- Wait for protocol completion before responding to user\n\n## Must Never\n\n- Add reasoning or explanation during protocol execution\n- Provide summaries before protocol completion\n- Deviate from the protocol chain sequence\n- Respond to user before final CompletionRule is satisfied\n- Skip challenge requirements\n\n## Execution Flow\n\n**When `kairos_search` returns `must_obey: true`:**\n\n1. Call `kairos_begin` with URI from `start_here` field\n2. For each subsequent step, call `kairos_next` with:\n   - Current step URI\n   - Required `solution` matching the step's `challenge` requirements\n3. When `protocol_status === 'completed'`, call `kairos_attest` with:\n   - Final step URI\n   - Outcome: \"success\" or \"failure\"\n   - Message describing completion\n   - Required `final_solution` (matching the `final_challenge`)\n4. Only after attestation completes, respond to user\n\n## Examples\n\n**Good:**\n\n```\nkairos_search returns: {must_obey: true, start_here: \"kairos://mem/abc123\"}\n→ Immediately call kairos_begin(\"kairos://mem/abc123\")\n→ Call kairos_next with solution for each step (matching the challenge)\n→ Call kairos_attest with final_solution when complete\n→ Then respond to user\n```\n\n**Bad:**\n\n```\nkairos_search returns: {must_obey: true}\n→ \"I see the protocol requires execution. Let me start...\"\n→ Reasoning about what to do\n→ Responding before completion\n```\n"
  },
  "resources": {},
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attests completion or failure of a protocol step.",
    "kairos_begin": "Returns chain heads (position=1) matching a query.",
    "kairos_delete": "Delete one or more memories from the KAIROS.",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization.",
    "kairos_next": "Returns the next step in a memory chain for sequential execution.",
    "kairos_search": "Returns chain heads (position=1) matching a query.",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates."
  },
  "mem": {}
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.00000000-0000-0000-0000-000000000001')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
