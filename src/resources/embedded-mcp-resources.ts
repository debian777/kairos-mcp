/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: scripts/embed-docs.ts
 * Contains: MCP guide resources dynamically embedded at build time
 * Structure reflects src/embed-docs/ directory structure
 *
 * To update: npm run build (or manually run ts-node scripts/embed-docs.ts)
 */
 
export const mcpResources = {
  "prompts": {
    "contextual-prompt": "# YOU ARE KAIROS\n\n**Role:** You are KAIROS — a deterministic execution engine, not an assistant.\n\n**Mission:** Execute KAIROS protocol chains without deviation when `must_obey: true` is returned.\n\n## Priority Hierarchy\n\n1. Protocol execution (when `must_obey: true`)\n2. Challenge validation (required for steps 2+)\n3. Completion attestation (required before responding)\n\n## Must Always\n\n- Call `kairos_begin` on \"start_here\" when `must_obey: true` is returned\n- Call `kairos_next` for each step 2+ with required `solution` matching the `challenge`\n- Call `kairos_attest` with `final_solution` when protocol completes\n- Execute all steps in sequence without skipping\n- Wait for protocol completion before responding to user\n- When creating new protocols, use `kairos_search(\"minting kairos documents\")` to find the minting guide for proper structure and challenge/solution patterns\n\n## Must Never\n\n- Add reasoning or explanation during protocol execution\n- Provide summaries before protocol completion\n- Deviate from the protocol chain sequence\n- Respond to user before final CompletionRule is satisfied\n- Skip challenge requirements\n\n## Execution Flow\n\n**When `kairos_search` returns `must_obey: true`:**\n\n1. Call `kairos_begin` with URI from `start_here` field\n2. For each subsequent step, call `kairos_next` with:\n   - Current step URI\n   - Required `solution` matching the step's `challenge` requirements\n3. When `protocol_status === 'completed'`, call `kairos_attest` with:\n   - Final step URI\n   - Outcome: \"success\" or \"failure\"\n   - Message describing completion\n   - Required `final_solution` (matching the `final_challenge`)\n4. Only after attestation completes, respond to user\n\n**When `kairos_search` returns `must_obey: false` with `choices` array:**\n\n1. You MUST choose one protocol from the `choices` array\n2. Call `kairos_begin` with the chosen protocol's URI from `choices[].uri`\n3. This commits to that protocol - `kairos_begin` will return `must_obey: true`\n4. Once `must_obey: true` is returned from `kairos_begin`, follow the normal execution flow above\n5. The chosen protocol becomes mandatory - you cannot skip or change to another protocol after committing\n\n**Important:** `must_obey: false` with `choices` does NOT mean protocols are optional. It means you must choose one, and once chosen via `kairos_begin`, that protocol becomes mandatory (`must_obey: true`).\n\n## Examples\n\n**Good:**\n\n```\nkairos_search returns: {must_obey: true, start_here: \"kairos://mem/abc123\"}\n→ Immediately call kairos_begin(\"kairos://mem/abc123\")\n→ Call kairos_next with solution for each step (matching the challenge)\n→ Call kairos_attest with final_solution when complete\n→ Then respond to user\n```\n\n**Good (Multiple Choices):**\n\n```\nkairos_search returns: {must_obey: false, choices: [{uri: \"kairos://mem/abc123\", label: \"Protocol A\"}, {uri: \"kairos://mem/def456\", label: \"Protocol B\"}]}\n→ Choose one: kairos_begin(\"kairos://mem/abc123\")  // This commits to Protocol A\n→ kairos_begin returns: {must_obey: true, ...}  // Now execution is mandatory\n→ Continue with kairos_next for steps 2+, kairos_attest at completion\n→ Then respond to user\n```\n\n**Bad:**\n\n```\nkairos_search returns: {must_obey: true}\n→ \"I see the protocol requires execution. Let me start...\"\n→ Reasoning about what to do\n→ Responding before completion\n```\n\n**Bad (Multiple Choices):**\n\n```\nkairos_search returns: {must_obey: false, choices: [...]}\n→ \"I see multiple protocols are available. They are optional...\"\n→ Not calling kairos_begin\n→ Responding without committing to any protocol\n```\n"
  },
  "resources": {
    "minting-with-challenges": "# Minting KAIROS Documents with Challenge/Solution Workflow\n\n**Status:** Active  \n**Purpose:** Guide for AI assistants on how to mint KAIROS protocol documents using the challenge/solution workflow instead of the legacy proof-of-work system.\n\n---\n\n## MISSION\n\nCreate and store KAIROS protocol documents using `kairos_mint` that define **challenges** (not proof-of-work) which are validated via **solutions** in the `kairos_next` workflow. Maintain exact consistency between markdown structure and the resulting memory chain behavior.\n\n---\n\n## STRUCTURE\n\n**Document Organization:**\n- **H1 (# Title)**: Defines a protocol chain (one H1 = one chain)\n- **H2 (## Step N)**: Defines individual steps within the chain\n- **Challenge Markers**: Lines starting with `PROOF OF WORK:`, `CHALLENGE:`, or similar that define what must be completed\n\n**Memory Mapping:**\n- Each H1 section → One protocol chain\n- Each H2 section → One memory step\n- Challenge markers within H2 → Become `proof_of_work` metadata on that memory\n\n**Processing Flow:**\n```\nMarkdown Document\n  ↓\nkairos_mint(markdown_doc, llm_model_id)\n  ↓\nMemory Chain (array of Memory objects)\n  ↓\nEach Memory has:\n  - memory_uuid\n  - label (from H2 heading)\n  - text (H2 content)\n  - proof_of_work (parsed from challenge markers)\n```\n\n---\n\n## CONTENT TYPES\n\n### Challenge Definitions\n\n**Format 1 - Shell Command:**\n```markdown\nPROOF OF WORK: timeout 30s echo \"test\"\n```\n\n**Format 2 - MCP Tool:**\n```markdown\nPROOF OF WORK: mcp tool_name arg1=value1\n```\n\n**Format 3 - User Input:**\n```markdown\nPROOF OF WORK: user_input \"Confirm completion\"\n```\n\n**Format 4 - Comment:**\n```markdown\nPROOF OF WORK: comment min_length=50\n```\n\n**Parsing Rules:**\n- Lines matching `PROOF OF WORK:` pattern are extracted\n- Command/definition follows the colon\n- Shell commands support timeout syntax: `timeout Ns command`\n- Default type is `shell` if not specified\n\n### Challenge Types\n\n**Shell (`shell`):**\n- Requires execution of a shell command\n- Validated by exit code (0 = success)\n- Format: `PROOF OF WORK: timeout Ns command` or `PROOF OF WORK: command`\n\n**MCP Tool (`mcp`):**\n- Requires calling an MCP tool\n- Format: `PROOF OF WORK: mcp tool_name args...`\n\n**User Input (`user_input`):**\n- Requires user confirmation\n- Format: `PROOF OF WORK: user_input \"prompt text\"`\n\n**Comment (`comment`):**\n- Requires a verification comment\n- Format: `PROOF OF WORK: comment min_length=N`\n\n---\n\n## MUST ALWAYS\n\n### Document Structure\n- Use H1 (`# Title`) for protocol chain labels\n- Use H2 (`## Step N`) for individual steps\n- Place challenge markers **within** the H2 section they apply to\n- Each H1 creates a separate protocol chain\n\n### Challenge Placement\n- Place challenge markers at the **end** of an H2 section to apply to that step\n- Place challenge markers **between** H2 sections to apply to the next step\n- Only the **last** challenge marker in a section applies (if multiple exist)\n\n### kairos_mint Usage\n- Always provide `markdown_doc` as a string (can be JSON stringified)\n- Always provide `llm_model_id` (e.g., `\"minimax/minimax-m2:free\"`)\n- Use `force_update: true` to overwrite existing chains with the same label\n\n### Solution Submission\n- Use `kairos_next(uri, solution)` to submit solutions (not `proof_of_work`)\n- Solution structure matches challenge type:\n  - `shell`: `{type: 'shell', shell: {exit_code, stdout, stderr, duration_seconds}}`\n  - `mcp`: `{type: 'mcp', mcp: {tool_name, arguments, result, success}}`\n  - `user_input`: `{type: 'user_input', user_input: {confirmation, timestamp}}`\n  - `comment`: `{type: 'comment', comment: {text}}`\n\n---\n\n## MUST NEVER\n\n### Document Structure\n- **NEVER** mix H1 and H2 in unpredictable ways\n- **NEVER** place challenge markers outside H2 sections (they'll be ignored)\n- **NEVER** use `PROOF OF WORK` terminology in user-facing content (use \"challenge\" when explaining)\n\n### Challenge Definitions\n- **NEVER** use the old `proof_of_work` field in API calls (use `solution` instead)\n- **NEVER** skip challenge validation - `kairos_next` requires solutions for steps with challenges\n- **NEVER** submit solutions that don't match the challenge type\n\n### kairos_mint\n- **NEVER** pass markdown as an object - always as a string\n- **NEVER** omit `llm_model_id` - it's required\n- **NEVER** store duplicate chains without `force_update: true`\n\n### Workflow Confusion\n- **NEVER** confuse `challenge` (output from `kairos_next`) with `solution` (input to `kairos_next`)\n- **NEVER** use `proof_of_work` field - it's deprecated, use `solution`\n- **NEVER** assume step 1 requires a solution (only steps 2+ require solutions)\n\n---\n\n## WORKFLOW EXAMPLES\n\n### Example 1: Simple Protocol with Shell Challenges\n\n```markdown\n# Simple Setup Protocol\n\n## Step 1: Initialize\nCreate the project structure.\n\nPROOF OF WORK: timeout 10s mkdir -p project/src\n\n## Step 2: Configure\nSet up configuration files.\n\nPROOF OF WORK: timeout 5s echo \"config\" > project/config.json\n\n## Step 3: Verify\nCheck that everything works.\n\nPROOF OF WORK: timeout 5s test -f project/config.json\n```\n\n**Minting:**\n```javascript\nawait kairos_mint({\n  markdown_doc: markdownText,\n  llm_model_id: 'minimax/minimax-m2:free'\n});\n```\n\n**Execution Flow:**\n1. `kairos_search(\"simple setup\")` → Returns `must_obey: true` with `start_here` URI\n2. `kairos_begin(start_here_uri)` → Returns step 1 with `challenge: {type: 'shell', ...}`\n3. `kairos_next(step1_uri, solution: {type: 'shell', shell: {...}})` → Returns step 2\n4. Continue through all steps with solutions\n5. `kairos_attest(final_uri, final_solution: {...})` → Complete\n\n### Example 2: Protocol with Comment Challenge\n\n```markdown\n# Documentation Review Protocol\n\n## Step 1: Review\nReview the documentation for accuracy.\n\nPROOF OF WORK: comment min_length=50\n\n## Step 2: Approve\nApprove the documentation.\n\nPROOF OF WORK: user_input \"Type 'approved' to confirm\"\n```\n\n**Solution Submission:**\n```javascript\n// For step 1 (comment challenge)\nawait kairos_next(step1_uri, {\n  solution: {\n    type: 'comment',\n    comment: {\n      text: 'Reviewed documentation. All sections are accurate and up-to-date. No changes needed.'\n    }\n  }\n});\n\n// For step 2 (user input challenge)\nawait kairos_next(step2_uri, {\n  solution: {\n    type: 'user_input',\n    user_input: {\n      confirmation: 'approved',\n      timestamp: new Date().toISOString()\n    }\n  }\n});\n```\n\n### Example 3: Multi-Chain Document\n\n```markdown\n# Protocol A\n\n## Step 1\nContent for protocol A step 1.\n\n# Protocol B\n\n## Step 1\nContent for protocol B step 1.\n\nPROOF OF WORK: timeout 5s echo \"protocol B\"\n```\n\n**Result:** Two separate protocol chains are created (one for Protocol A, one for Protocol B).\n\n---\n\n## CHALLENGE vs SOLUTION NOMENCLATURE\n\n**Important Distinction:**\n- **Challenge** = What `kairos_next` **returns** (what the AI must complete)\n- **Solution** = What you **submit** to `kairos_next` (proof you completed it)\n\n**Terminology in Markdown:**\n- Markdown uses `PROOF OF WORK:` syntax (legacy naming)\n- Internal representation uses `proof_of_work` metadata\n- API uses `challenge` (output) and `solution` (input)\n\n**Why the Confusion:**\n- Historical naming: \"proof of work\" was the original term\n- Modern naming: \"challenge/solution\" better describes the workflow\n- Backward compatibility: Markdown still accepts `PROOF OF WORK:` syntax\n\n---\n\n## VALIDATION RULES\n\n### Challenge Validation\n- Shell challenges: Exit code 0 = success, non-zero = failure\n- MCP challenges: `success: true` required\n- User input: Any non-empty `confirmation` accepted\n- Comment challenges: Minimum length enforced (default: 10 chars)\n\n### Step Progression\n- Step 1 (first H2): **No solution required** - call `kairos_begin` only\n- Steps 2+: **Solution required** - must submit matching `solution` to proceed\n- Protocol completion: Requires `kairos_attest` with `final_solution`\n\n### Error Handling\n- Invalid solution type → `must_obey: false` with error message\n- Missing solution → `must_obey: false` with blocking message\n- Failed challenge → Blocked from proceeding until retried with success\n\n---\n\n## MIGRATION FROM OLD WORKFLOW\n\n**Old Way (Deprecated):**\n```javascript\nkairos_next(uri, {proof_of_work: {...}})  // ❌ Deprecated\n```\n\n**New Way (Current):**\n```javascript\nkairos_next(uri, {solution: {...}})  // ✅ Correct\n```\n\n**Field Mapping:**\n- `proof_of_work` → `solution`\n- Structure remains the same (type-specific fields unchanged)\n- Validation logic unchanged\n\n---\n\n## QUICK REFERENCE\n\n| Operation | Tool | Required Fields |\n|-----------|------|----------------|\n| Mint document | `kairos_mint` | `markdown_doc`, `llm_model_id` |\n| Find protocol | `kairos_search` | `query` |\n| Start protocol | `kairos_begin` | `uri` (from `start_here`) |\n| Continue step | `kairos_next` | `uri`, `solution` (if challenge exists) |\n| Complete protocol | `kairos_attest` | `uri`, `outcome`, `message`, `final_solution` |\n\n---\n\n## COMMON PITFALLS\n\n1. **Forgetting solutions for step 2+**: Every step after step 1 requires a solution if it has a challenge\n2. **Wrong solution type**: Solution type must exactly match challenge type\n3. **Skipping validation**: Challenges are enforced - you cannot proceed without valid solutions\n4. **Using old field names**: Always use `solution`, never `proof_of_work` in API calls\n5. **Mixing H1 chains**: Each H1 creates a separate chain - don't mix steps between chains\n\n---\n\n**Last Updated:** 2025-12-08  \n**Related:** `kairos_mint`, `kairos_next`, `kairos_begin`, `kairos_attest`\n\n\n\n\n"
  },
  "templates": {
    "kairos-memory": "Retrieves a KAIROS memory by UUID"
  },
  "tools": {
    "kairos_attest": "Attests completion or failure of a protocol step.",
    "kairos_begin": "Returns chain heads (position=1) matching a query.",
    "kairos_delete": "Delete one or more memories from the KAIROS.",
    "kairos_mint": "Stores markdown documents as KAIROS memories with automatic header-based organization.",
    "kairos_next": "Returns the next step in a memory chain for sequential execution.",
    "kairos_search": "Returns chain heads (position=1) matching a query. When multiple matches return choices, call kairos_begin with a choice URI to commit to that protocol (must_obey: true then applies).",
    "kairos_update": "Update one or more memories in the KAIROS using markdown_doc or updates."
  },
  "mem": {}
};
 
/**
 * Get prompts object
 */
export function getPrompts(): Record<string, any> {
  return mcpResources.prompts || {};
}

/**
 * Get resources object
 */
export function getResources(): Record<string, any> {
  return mcpResources.resources || {};
}

/**
 * Get templates object
 */
export function getTemplates(): Record<string, any> {
  return mcpResources.templates || {};
}

/**
 * Get tools object
 */
export function getTools(): Record<string, any> {
  return mcpResources.tools || {};
}

/**
 * Get mem object
 */
export function getMem(): Record<string, any> {
  return mcpResources.mem || {};
}

/**
 * Get a prompt by key (e.g. 'contextual-prompt')
 */
export function getPrompt(key: string): string | undefined {
  const prompts = (mcpResources.prompts || {}) as Record<string, string>;
  return prompts[key];
}

/**
 * Get a resource by key (e.g. 'TEST', 'doc.TEST', 'mem.00000000-0000-0000-0000-000000000001')
 */
export function getResource(key: string): string | any | undefined {
  const resources = (mcpResources.resources || {}) as Record<string, any>;
  const parts = key.split('.');
  let current: any = resources;
  for (const part of parts) {
    if (current && typeof current === 'object') {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

/**
 * Get a template by key (e.g. 'kairos-memory')
 */
export function getTemplate(key: string): string | undefined {
  const templates = (mcpResources.templates || {}) as Record<string, string>;
  return templates[key];
}

/**
 * Get a tool doc by key (e.g. 'kairos_begin')
 */
export function getToolDoc(key: string): string | undefined {
  const tools = (mcpResources.tools || {}) as Record<string, string>;
  return tools[key];
}

/**
 * Get all available resource categories and names
 */
export function listResourceKeys(): Record<string, string[]> {
  const prompts = Object.keys((mcpResources.prompts || {}) as Record<string, unknown>);
  const resources = collectAllKeys((mcpResources.resources || {}) as Record<string, unknown>);
  const templates = Object.keys((mcpResources.templates || {}) as Record<string, unknown>);
  const tools = Object.keys((mcpResources.tools || {}) as Record<string, unknown>);
  
  const result: Record<string, string[]> = { prompts, resources, templates, tools };
  
  // Add any other top-level categories
  for (const [key, value] of Object.entries(mcpResources)) {
    if (!['prompts', 'resources', 'templates', 'tools'].includes(key)) {
      if (typeof value === 'object' && value !== null) {
        result[key] = Object.keys(value as Record<string, unknown>);
      }
    }
  }

  return result;
}

function collectAllKeys(obj: any, prefix: string = '', keys: string[] = []): string[] {
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'string') {
      keys.push(fullKey);
    } else if (typeof value === 'object' && value !== null) {
      collectAllKeys(value, fullKey, keys);
    }
  }
  return keys;
}
