# Minting KAIROS Documents with Challenge/Solution Workflow

**Status:** Active  
**Purpose:** Guide for AI assistants on how to mint KAIROS protocol documents using the challenge/solution workflow instead of the legacy proof-of-work system.

---

## MISSION

Create and store KAIROS protocol documents using `kairos_mint` that define **challenges** (not proof-of-work) which are validated via **solutions** in the `kairos_next` workflow. Maintain exact consistency between markdown structure and the resulting memory chain behavior.

---

## STRUCTURE

**Document Organization:**

- **H1 (# Title)**: Defines a protocol chain (one H1 = one chain)
- **H2 (## Step N)**: Defines individual steps within the chain
- **Challenge Markers**: Lines starting with `PROOF OF WORK:`, `CHALLENGE:`, or similar that define what must be completed

**Memory Mapping:**

- Each H1 section → One protocol chain
- Each H2 section → One memory step
- Challenge markers within H2 → Become `proof_of_work` metadata on that memory

**Processing Flow:**

```
Markdown Document
  ↓
kairos_mint(markdown_doc, llm_model_id)
  ↓
Memory Chain (array of Memory objects)
  ↓
Each Memory has:
  - memory_uuid
  - label (from H2 heading)
  - text (H2 content)
  - proof_of_work (parsed from challenge markers)
```

---

## CONTENT TYPES

### Challenge Definitions

**Format 1 - Shell Command:**

```markdown
PROOF OF WORK: timeout 30s echo "test"
```

**Format 2 - MCP Tool:**

```markdown
PROOF OF WORK: mcp tool_name arg1=value1
```

**Format 3 - User Input:**

```markdown
PROOF OF WORK: user_input "Confirm completion"
```

**Format 4 - Comment:**

```markdown
PROOF OF WORK: comment min_length=50
```

**Parsing Rules:**

- Lines matching `PROOF OF WORK:` pattern are extracted
- Command/definition follows the colon
- Shell commands support timeout syntax: `timeout Ns command`
- Default type is `shell` if not specified

### Challenge Types

**Shell (`shell`):**

- Requires execution of a shell command
- Validated by exit code (0 = success)
- Format: `PROOF OF WORK: timeout Ns command` or `PROOF OF WORK: command`

**MCP Tool (`mcp`):**

- Requires calling an MCP tool
- Format: `PROOF OF WORK: mcp tool_name args...`

**User Input (`user_input`):**

- Requires user confirmation
- Format: `PROOF OF WORK: user_input "prompt text"`

**Comment (`comment`):**

- Requires a verification comment
- Format: `PROOF OF WORK: comment min_length=N`

---

## MUST ALWAYS

### Document Structure

- Use H1 (`# Title`) for protocol chain labels
- Use H2 (`## Step N`) for individual steps
- Place challenge markers **within** the H2 section they apply to
- Each H1 creates a separate protocol chain

### Challenge Placement

- Place challenge markers at the **end** of an H2 section to apply to that step
- Place challenge markers **between** H2 sections to apply to the next step
- Only the **last** challenge marker in a section applies (if multiple exist)

### kairos_mint Usage

- Always provide `markdown_doc` as a string (can be JSON stringified)
- Always provide `llm_model_id` (e.g., `"minimax/minimax-m2:free"`)
- Use `force_update: true` to overwrite existing chains with the same label

### Solution Submission

- Use `kairos_next(uri, solution)` to submit solutions (not `proof_of_work`)
- Solution structure matches challenge type:
  - `shell`: `{type: 'shell', shell: {exit_code, stdout, stderr, duration_seconds}}`
  - `mcp`: `{type: 'mcp', mcp: {tool_name, arguments, result, success}}`
  - `user_input`: `{type: 'user_input', user_input: {confirmation, timestamp}}`
  - `comment`: `{type: 'comment', comment: {text}}`

---

## MUST NEVER

### Document Structure

- **NEVER** mix H1 and H2 in unpredictable ways
- **NEVER** place challenge markers outside H2 sections (they'll be ignored)
- **NEVER** use `PROOF OF WORK` terminology in user-facing content (use "challenge" when explaining)

### Challenge Definitions

- **NEVER** use the old `proof_of_work` field in API calls (use `solution` instead)
- **NEVER** skip challenge validation - `kairos_next` requires solutions for steps with challenges
- **NEVER** submit solutions that don't match the challenge type

### kairos_mint

- **NEVER** pass markdown as an object - always as a string
- **NEVER** omit `llm_model_id` - it's required
- **NEVER** store duplicate chains without `force_update: true`

### Workflow Confusion

- **NEVER** confuse `challenge` (output from `kairos_next`) with `solution` (input to `kairos_next`)
- **NEVER** use `proof_of_work` field - it's deprecated, use `solution`
- **NEVER** assume step 1 requires a solution (only steps 2+ require solutions)

---

## WORKFLOW EXAMPLES

### Example 1: Simple Protocol with Shell Challenges

```markdown
# Simple Setup Protocol

## Step 1: Initialize

Create the project structure.

PROOF OF WORK: timeout 10s mkdir -p project/src

## Step 2: Configure

Set up configuration files.

PROOF OF WORK: timeout 5s echo "config" > project/config.json

## Step 3: Verify

Check that everything works.

PROOF OF WORK: timeout 5s test -f project/config.json
```

**Minting:**

```javascript
await kairos_mint({
  markdown_doc: markdownText,
  llm_model_id: "minimax/minimax-m2:free",
});
```

**Execution Flow:**

1. `kairos_search("simple setup")` → Returns `must_obey: true` with `start_here` URI
2. `kairos_begin(start_here_uri)` → Returns step 1 with `challenge: {type: 'shell', ...}`
3. `kairos_next(step1_uri, solution: {type: 'shell', shell: {...}})` → Returns step 2
4. Continue through all steps with solutions
5. `kairos_attest(final_uri, final_solution: {...})` → Complete

### Example 2: Protocol with Comment Challenge

```markdown
# Documentation Review Protocol

## Step 1: Review

Review the documentation for accuracy.

PROOF OF WORK: comment min_length=50

## Step 2: Approve

Approve the documentation.

PROOF OF WORK: user_input "Type 'approved' to confirm"
```

**Solution Submission:**

```javascript
// For step 1 (comment challenge)
await kairos_next(step1_uri, {
  solution: {
    type: "comment",
    comment: {
      text: "Reviewed documentation. All sections are accurate and up-to-date. No changes needed.",
    },
  },
});

// For step 2 (user input challenge)
await kairos_next(step2_uri, {
  solution: {
    type: "user_input",
    user_input: {
      confirmation: "approved",
      timestamp: new Date().toISOString(),
    },
  },
});
```

### Example 3: Multi-Chain Document

```markdown
# Protocol A

## Step 1

Content for protocol A step 1.

# Protocol B

## Step 1

Content for protocol B step 1.

PROOF OF WORK: timeout 5s echo "protocol B"
```

**Result:** Two separate protocol chains are created (one for Protocol A, one for Protocol B).

---

## CHALLENGE vs SOLUTION NOMENCLATURE

**Important Distinction:**

- **Challenge** = What `kairos_next` **returns** (what the AI must complete)
- **Solution** = What you **submit** to `kairos_next` (proof you completed it)

**Terminology in Markdown:**

- Markdown uses `PROOF OF WORK:` syntax (legacy naming)
- Internal representation uses `proof_of_work` metadata
- API uses `challenge` (output) and `solution` (input)

**Why the Confusion:**

- Historical naming: "proof of work" was the original term
- Modern naming: "challenge/solution" better describes the workflow
- Backward compatibility: Markdown still accepts `PROOF OF WORK:` syntax

---

## VALIDATION RULES

### Challenge Validation

- Shell challenges: Exit code 0 = success, non-zero = failure
- MCP challenges: `success: true` required
- User input: Any non-empty `confirmation` accepted
- Comment challenges: Minimum length enforced (default: 10 chars)

### Step Progression

- Step 1 (first H2): **No solution required** - call `kairos_begin` only
- Steps 2+: **Solution required** - must submit matching `solution` to proceed
- Protocol completion: Requires `kairos_attest` with `final_solution`

### Error Handling

- Invalid solution type → `must_obey: false` with error message
- Missing solution → `must_obey: false` with blocking message
- Failed challenge → Blocked from proceeding until retried with success

---

## MIGRATION FROM OLD WORKFLOW

**Old Way (Deprecated):**

```javascript
kairos_next(uri, {proof_of_work: {...}})  // ❌ Deprecated
```

**New Way (Current):**

```javascript
kairos_next(uri, {solution: {...}})  // ✅ Correct
```

**Field Mapping:**

- `proof_of_work` → `solution`
- Structure remains the same (type-specific fields unchanged)
- Validation logic unchanged

---

## QUICK REFERENCE

| Operation         | Tool            | Required Fields                               |
| ----------------- | --------------- | --------------------------------------------- |
| Mint document     | `kairos_mint`   | `markdown_doc`, `llm_model_id`                |
| Find protocol     | `kairos_search` | `query`                                       |
| Start protocol    | `kairos_begin`  | `uri` (from `start_here`)                     |
| Continue step     | `kairos_next`   | `uri`, `solution` (if challenge exists)       |
| Complete protocol | `kairos_attest` | `uri`, `outcome`, `message`, `final_solution` |

---

## COMMON PITFALLS

1. **Forgetting solutions for step 2+**: Every step after step 1 requires a solution if it has a challenge
2. **Wrong solution type**: Solution type must exactly match challenge type
3. **Skipping validation**: Challenges are enforced - you cannot proceed without valid solutions
4. **Using old field names**: Always use `solution`, never `proof_of_work` in API calls
5. **Mixing H1 chains**: Each H1 creates a separate chain - don't mix steps between chains

---

**Last Updated:** 2025-12-08  
**Related:** `kairos_mint`, `kairos_next`, `kairos_begin`, `kairos_attest`
