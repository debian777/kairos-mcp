# KAIROS full stack Helm chart

Deploys **Qdrant** (HA, odd replicas for quorum, default 3) and **kairos-mcp** app (2 replicas). Redis, Keycloak, and Postgres can be **external** (your operators) or created by this chart via operator CRs.

## Prerequisites

- Kubernetes cluster
- **Operators** installed (see [docs/OPERATORS.md](docs/OPERATORS.md) for step-by-step install):
  - Redis (e.g. Spotahome redis-operator)
  - Keycloak operator
  - Postgres (e.g. Percona PostgreSQL operator)

## Credentials (autogenerated, stored only in K8s)

- Set `credentials.autoGenerate: true` (default): a **pre-install hook** creates a Secret with random `redis-password`, `keycloak-db-password`, `session-secret`. Passwords are **not** written to values or disk; they exist only in the Kubernetes Secret. The hook is idempotent (skips if the Secret already exists).
- To use your own secret: set `credentials.existingSecret` to the Secret name; no generation runs.
- The app uses `credentials.name` (or `app.existingSecret`) for `SESSION_SECRET`; set `app.redisUrl` in values (or provide `redis-url` in your secret).

## Cluster configuration (optional)

- **Use your own clusters**: set `redisCluster.useOwnCluster`, `keycloakInstance.useOwnCluster`, or `postgresCluster.useOwnCluster` to `true` and set `app.redisUrl`, `app.keycloakInternalUrl`, etc. No CRs are created.
- **Let the chart create clusters**: set `redisCluster.enabled`, `keycloakInstance.enabled`, or `postgresCluster.enabled` to `true` (operators must be installed). Override with `redisCluster.customSpec`, `keycloakInstance.customSpec`, or `postgresCluster.customSpec` for full control.

## HA and affinity

- **Single-node (default):** `ha.spreadAcrossNodes: false` — pods can colocate; use for local or single-node test.
- **Multi-node:** Set `ha.spreadAcrossNodes: true` — the app gets **preferred** pod anti-affinity on `kubernetes.io/hostname` so replicas prefer different nodes. For **Qdrant**, set `qdrant.affinity` to the same pattern (see the commented block in `values.yaml` under `qdrant.affinity`).

You can override with full `app.affinity` / `qdrant.affinity` when `ha.spreadAcrossNodes` is false.

## HPA (Horizontal Pod Autoscaler)

- **App:** `app.hpa.enabled: true` — HPA targets the kairos-mcp Deployment (CPU%). Requires [metrics-server](https://kubernetes.io/docs/tasks/deploy-cluster-tools/resource-metrics-pipeline/).
- **Qdrant:** `qdrant.hpa.enabled: true` — HPA targets the Qdrant StatefulSet. Keep `minReplicas` odd (3, 5, 7) for consensus quorum. Tune `minReplicas` / `maxReplicas` and `targetCPUUtilizationPercentage` in values.

## VPA (Vertical Pod Autoscaler)

[VPA](https://kubernetes.io/docs/concepts/workloads/autoscaling/vertical-pod-autoscale/) adjusts CPU/memory **requests and limits** from actual usage. It is not built-in: install the [VPA controller and CRD](https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler) (`autoscaling.k8s.io/v1`) in the cluster first.

- **App:** `app.vpa.enabled: true` — VPA for the kairos-mcp Deployment.
- **Qdrant:** `qdrant.vpa.enabled: true` — VPA for the Qdrant StatefulSet. Set `minAllowed` / `maxAllowed` and `updateMode` (e.g. `Recreate` or `Off` to only view recommendations).
- **Postgres (operator-managed):** `postgresCluster.vpa.enabled: true` and set `postgresCluster.vpa.targetName` (and optionally `targetKind`) to the workload created by the Percona operator. Use `updateMode: Off` for DBs and apply recommendations manually after observing usage; after **increasing volume size** significantly, adopt VPA’s higher memory recommendation (or raise memory requests yourself) so the DB has enough memory for the larger dataset.

## Monitoring (ServiceMonitor and alerts)

Requires [Prometheus Operator](https://prometheus-operator.dev/) (ServiceMonitor and PrometheusRule CRDs). The **app** exposes Prometheus metrics on `app.metricsPort` (default 9090) at `/metrics`; **Qdrant** exposes `/metrics` on port 6333. Enable `monitoring.serviceMonitor.app.enabled` and `monitoring.serviceMonitor.qdrant.enabled`; set `release` (e.g. `prometheus`) so Prometheus selects them. Optional: `monitoring.serviceMonitor.redis` / `keycloak` / `postgres` with `serviceNamespace` and `serviceSelector`. Set `monitoring.prometheusRule.enabled: true` for default alerts (KAIROSAppDown, KAIROSAppHighErrorRate, KAIROSQdrantDown); set `monitoring.prometheusRule.release` for selection. Override rules with `monitoring.prometheusRule.rules`.

## Operator pre-check

When any of `redisCluster.enabled`, `keycloakInstance.enabled`, or `postgresCluster.enabled` is `true`, a **pre-install hook** runs before the rest of the release. It checks that the required operator CRDs exist (e.g. `redisfailovers.databases.spotahome.com`, `keycloaks.k8s.keycloak.org`, `perconapgclusters.pgv2.percona.com`). If a CRD is missing, the install fails with a clear message so you can install that operator first (see [docs/OPERATORS.md](docs/OPERATORS.md)).

## Gateway API (same FQDN, path-based — no Ingress)

Expose **MCP** and **Keycloak** on the **same FQDN** using [Gateway API](https://gateway-api.sigs.k8s.io/guides/getting-started/migrating-from-ingress/) (not Ingress):

- **MCP** at `https://<hostname>/`
- **IdP (Keycloak)** at `https://<hostname>/sso` (app uses `/auth` for OAuth callback; use a different path for IdP, e.g. `/sso`, `/oidc`, `/identity`)

Set `gateway.enabled: true`, `gateway.hostname`, and either create a Gateway (`gateway.createGateway: true` + `gateway.gatewayClassName`) or attach to an existing one (`gateway.existingGatewayName`). Set `gateway.routes.keycloak.serviceName` (and `serviceNamespace` if Keycloak is in another namespace) and `gateway.routes.keycloak.path` (default `/sso` — the app uses `/auth` for OAuth callback, logout, etc.).

**IdP under a path:** Keycloak (or any IdP) must use the same path as the route. Set `KC_HTTP_RELATIVE_PATH=/sso` (or your chosen path: `/oidc`, `/identity`, etc.) in the Keycloak deployment/CR. In Keycloak, set the realm's redirect URIs to the app's callback (e.g. `https://<hostname>/auth/callback`).

**Cross-namespace Keycloak:** If the Keycloak service is in another namespace (e.g. `keycloak`), the chart can create a **ReferenceGrant** in that namespace so the HTTPRoute can reference the service. The release must have permission to create resources in the Keycloak namespace; otherwise create the ReferenceGrant there manually (see [Gateway API ReferenceGrant](https://gateway-api.sigs.k8s.io/api-types/referencegrant/)).

**TLS / Let's Encrypt (default):** With `gateway.tls.certManager.enabled: true` (default), the chart creates a cert-manager **Certificate** that requests a TLS certificate from the issuer in `gateway.tls.certManager.issuerRef` (default: `ClusterIssuer` named `letsencrypt-prod`). You must install [cert-manager](https://cert-manager.io/) and create a ClusterIssuer for Let's Encrypt (e.g. [HTTP-01](https://cert-manager.io/docs/configuration/acme/http01/) or DNS-01). The Gateway then uses the Secret that cert-manager creates. To use your own certificate instead, set `gateway.tls.certManager.enabled: false` and `gateway.tls.secretName` to the name of your TLS Secret.

## Install

1. Install operators (see [docs/OPERATORS.md](docs/OPERATORS.md)) if you use chart-created clusters (`*Cluster.enabled` or `*Instance.enabled`).

2. Update dependencies and install:

   ```bash
   helm dependency update
   helm install kairos . -n kairos --create-namespace -f my-values.yaml
   ```

3. In `my-values.yaml` set at least:
   - `app.redisUrl` — Redis URL (e.g. `redis://kairos-redis-rfr.kairos.svc:6379` or with auth `redis://:PASSWORD@host:6379`; for no plaintext password use a secret with key `redis-url` and set `app.existingSecret`)
   - `app.qdrantUrl` — e.g. `http://kairos-qdrant:6333`
   - `app.keycloakInternalUrl` — Keycloak internal URL
   - `app.auth.callbackBaseUrl` — Public base URL for auth redirects

## What this chart deploys

- **Qdrant** (subchart) — 3 replicas by default (use odd count for consensus quorum), persistent storage, HTTP 6333 / gRPC 6334
- **kairos-mcp** — Deployment with 2 replicas, image `debian777/kairos-mcp:latest`, ports 3000 (HTTP) and 9090 (metrics)

Redis, Keycloak, and Postgres are not part of this chart; point the app at your operator-managed instances via the values above.

**Credentials:** Passwords are autogenerated by a pre-install Job and stored only in the Secret `credentials.name`; set `credentials.existingSecret` to use your own. See [docs/OPERATORS.md](docs/OPERATORS.md) for operator install and Keycloak DB secret layout.
