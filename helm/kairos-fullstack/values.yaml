# KAIROS full stack — Qdrant + app. Redis, Keycloak, Postgres via operators (see docs/OPERATORS.md).
# Credentials: autogenerated and stored only in K8s Secret (see credentials below).

# -----------------------------------------------------------------------------
# Credentials — autogenerate and store only in K8s Secret (no values files).
# Set existingSecret to use your own secret; otherwise a pre-install hook creates
# a Secret with redis-password, keycloak-db-password, session-secret (random).
# -----------------------------------------------------------------------------
credentials:
  # Secret name the chart uses (created by hook if not existingSecret)
  name: kairos-fullstack-credentials
  # Use your own secret; if set, no Secret is created and no passwords generated
  existingSecret: ""
  # When true and existingSecret is empty, a pre-install Job creates the Secret with random passwords (idempotent: skips if Secret already exists)
  autoGenerate: true

# -----------------------------------------------------------------------------
# HA — spread pods across nodes (set true for multi-node; false for single-node test)
# When true, app and Qdrant get preferred pod anti-affinity on kubernetes.io/hostname.
# Override with app.affinity / qdrant.affinity for full control.
# -----------------------------------------------------------------------------
ha:
  spreadAcrossNodes: false

# -----------------------------------------------------------------------------
# Qdrant — HA: use odd replica count (3, 5, 7) for consensus quorum.
# -----------------------------------------------------------------------------
qdrant:
  enabled: true
  replicaCount: 3
  # When ha.spreadAcrossNodes is true, set this to spread Qdrant pods across nodes (subchart uses it):
  # affinity:
  #   podAntiAffinity:
  #     preferredDuringSchedulingIgnoredDuringExecution:
  #       - weight: 100
  #         podAffinityTerm:
  #           labelSelector:
  #             matchLabels:
  #               app.kubernetes.io/name: qdrant
  #           topologyKey: kubernetes.io/hostname
  affinity: {}
  persistence:
    enabled: true
    size: 10Gi
  config:
    log_level: INFO
    storage:
      storage_path: /qdrant/storage
  service:
    http:
      port: 6333
    grpc:
      port: 6334
  resources:
    limits:
      memory: 4Gi
    requests:
      memory: 1Gi
  # HPA for Qdrant. Keep minReplicas odd (3, 5, 7) for quorum. Requires metrics-server.
  hpa:
    enabled: false
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  # VPA (requires VPA controller + CRD autoscaling.k8s.io/v1). Adjusts CPU/memory requests/limits from usage.
  vpa:
    enabled: false
    updateMode: Recreate   # or Off, Initial, InPlaceOrRecreate
    minAllowed:
      memory: 512Mi
      cpu: 100m
    maxAllowed:
      memory: 8Gi
      cpu: 4

# -----------------------------------------------------------------------------
# KAIROS MCP app — 2 replicas. Set *Url to your operator-managed endpoints.
# -----------------------------------------------------------------------------
app:
  enabled: true
  name: kairos-mcp
  image:
    repository: debian777/kairos-mcp
    tag: latest
    pullPolicy: IfNotPresent
  replicaCount: 2
  port: 3000
  metricsPort: 9090
  # External endpoints (from your Redis / Keycloak / Postgres operators).
  # In-cluster Qdrant: use http://<release>-qdrant:6333 (e.g. kairos-qdrant:6333).
  redisUrl: ""          # e.g. redis://redis-master.redis.svc:6379 or redis://:secret@host:6379
  qdrantUrl: ""         # e.g. http://kairos-qdrant:6333 (this chart) or your Qdrant operator endpoint
  keycloakInternalUrl: ""  # e.g. http://keycloak-keycloak-operator.keycloak.svc:8080
  # Leave empty to use credentials.name (chart-managed secret with session-secret, redis-password, etc.)
  existingSecret: ""
  auth:
    enabled: true
    callbackBaseUrl: "" # e.g. https://kairos.example.com (use same as gateway.hostname when using Gateway API)
    realm: kairos-dev
    clientId: kairos-mcp
  resources:
    limits:
      memory: 1Gi
    requests:
      memory: 256Mi
  # When ha.spreadAcrossNodes is false, use this; when true, chart injects preferred anti-affinity
  affinity: {}
  nodeSelector: {}
  tolerations: []
  # HPA for the app. Requires metrics-server.
  hpa:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
  # VPA (requires VPA controller + CRD autoscaling.k8s.io/v1).
  vpa:
    enabled: false
    updateMode: Recreate
    minAllowed:
      memory: 128Mi
      cpu: 50m
    maxAllowed:
      memory: 2Gi
      cpu: 2

# -----------------------------------------------------------------------------
# Monitoring — ServiceMonitors and alerts (Prometheus Operator)
# Requires: Prometheus Operator CRD (ServiceMonitor, PrometheusRule). App exposes /metrics on app.metricsPort (9090); Qdrant exposes /metrics on port 6333. Redis/Keycloak/Postgres may require operator-side or exporter metrics.
# -----------------------------------------------------------------------------
monitoring:
  # ServiceMonitors: enable per component. Prometheus must select these (e.g. serviceMonitorSelector or release label).
  serviceMonitor:
    app:
      enabled: false
      interval: 30s
      scrapeTimeout: 10s
      release: ""
    qdrant:
      enabled: false
      interval: 30s
      scrapeTimeout: 10s
      release: ""
    # Redis/Keycloak/Postgres: enable only if your operator (or exporter) exposes a metrics Service; set serviceNamespace and serviceSelector to match.
    redis:
      enabled: false
      interval: 30s
      release: ""
      serviceNamespace: ""
      serviceSelector: {}
    keycloak:
      enabled: false
      interval: 30s
      release: ""
      serviceNamespace: ""
      serviceSelector: {}
    postgres:
      enabled: false
      interval: 30s
      release: ""
      serviceNamespace: ""
      serviceSelector: {}
  # PrometheusRule: alerts for app and Qdrant (and optional cluster rules). Requires Prometheus Operator.
  prometheusRule:
    enabled: false
    release: ""
    # Leave rules: [] to use chart defaults (app down, Qdrant down). Set to a list to override entirely.
    rules: []

# -----------------------------------------------------------------------------
# Gateway API — expose MCP and Keycloak on same FQDN (path-based). No Ingress.
# See https://gateway-api.sigs.k8s.io/guides/getting-started/migrating-from-ingress/
# IdP (Keycloak) must run with the same path (e.g. KC_HTTP_RELATIVE_PATH=/sso). App uses /auth for OAuth callback.
# -----------------------------------------------------------------------------
gateway:
  enabled: false
  # Create a Gateway in this release; or set createGateway: false and set existingGatewayName (and optional existingGatewayNamespace) to attach to an existing Gateway
  createGateway: true
  gatewayClassName: ""   # e.g. istio, kong, envoy - must exist in cluster (when createGateway: true)
  gatewayName: kairos-gateway
  existingGatewayName: ""   # when createGateway: false, Gateway to attach HTTPRoutes to
  existingGatewayNamespace: "" # namespace of existing Gateway (default: release namespace)
  hostname: ""           # e.g. kairos.example.com or *.example.com (required for routes)
  # TLS: cert-manager + Let's Encrypt by default; or set secretName to use an existing Secret
  tls:
    secretName: ""       # leave empty when certManager.enabled; otherwise Secret to use for HTTPS listener
    # Let's Encrypt via cert-manager (requires cert-manager + a ClusterIssuer, e.g. letsencrypt-prod)
    certManager:
      enabled: true
      issuerRef:
        name: letsencrypt-prod
        kind: ClusterIssuer
      # Secret name cert-manager will create; Gateway uses this for HTTPS listener
      secretName: ""     # default: <release-name>-gateway-tls
  # Path-based routing: same FQDN, IdP at path, MCP at / (app already uses /auth for callback, logout, etc.)
  routes:
    keycloak:
      path: /sso         # IdP at https://<hostname>/sso — set KC_HTTP_RELATIVE_PATH=/sso in Keycloak (alternatives: /oidc, /identity)
      serviceName: ""    # e.g. kairos-keycloak-keycloak-operator or keycloak service name
      serviceNamespace: "" # e.g. keycloak (default: keycloakInstance.namespace)
      port: 8080
    mcp:
      path: /            # MCP app at https://<hostname>/

# -----------------------------------------------------------------------------
# Optional: create cluster CRs (operators must be installed). Set enabled: true
# to let the chart create the CR. Set useOwnCluster: true to use your existing
# cluster and only configure app.*Url in values (no CR created).
# Use customSpec to override or merge with chart defaults.
# -----------------------------------------------------------------------------

redisCluster:
  enabled: false
  useOwnCluster: false   # true = use existing cluster; set app.redisUrl, no CR
  namespace: redis-operator
  name: kairos-redis
  # Chart default spec (RedisFailover). Override with customSpec.
  replicas: 2
  sentinelReplicas: 2
  # Full override (replaces chart defaults when set)
  customSpec: {}

keycloakInstance:
  enabled: false
  useOwnCluster: false   # true = use existing Keycloak; set app.keycloakInternalUrl, no CR
  namespace: keycloak
  name: kairos-keycloak
  # Chart default spec (Keycloak CR). Override with customSpec.
  replicas: 2
  # Postgres host for Keycloak DB (when postgresCluster.enabled or external)
  postgresHost: ""       # e.g. keycloak-db-primary.percona-pg.svc
  postgresDatabase: keycloak
  postgresUser: keycloak
  customSpec: {}

postgresCluster:
  enabled: false
  useOwnCluster: false   # true = use existing cluster; configure Keycloak DB URL, no CR
  namespace: percona-pg
  name: keycloak-db
  # Chart default spec (PerconaPGCluster). Override with customSpec.
  instances: 2
  storageSize: 5Gi
  customSpec: {}
  # VPA for Postgres (operator-managed). Target the Percona cluster's primary/replica workload by name.
  # Requires VPA installed. After increasing volume size, adopt VPA recommendations (or updateMode: Off and bump memory manually).
  vpa:
    enabled: false
    targetKind: StatefulSet
    targetName: ""   # e.g. keycloak-db-instance1; workload must be in release namespace (or helm template and apply -n <ns>)
    updateMode: Off   # Off recommended for DBs; apply recommendations after volume growth
    minAllowed:
      memory: 256Mi
      cpu: 100m
    maxAllowed:
      memory: 4Gi
      cpu: 2
